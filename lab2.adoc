= Лабораторная работа №2
:toc: macro
:toc-title: Содержание

include::Titulnik.adoc[]

toc::[]

== Введение

Данный отчет составлен на основе материалов лекции, посвященной основам разработки программного обеспечения для встраиваемых систем на микроконтроллерах. В лекции рассматриваются ключевые этапы преобразования исходного кода на языке C++ в исполняемый образ, готовый для загрузки в микроконтроллер, а также особенности работы среды разработки IAR Embedded Workbench for ARM.

Основное внимание уделяется "волшебству" компиляции и линковки, процессам инициалиции перед запуском `main()`, организации памяти и настройке проекта для отладки и выполнения на целевом устройстве — микроконтроллере STM32F411.

== Процесс преобразования кода C++ в исполняемую программу

Превращение кода C++ в работающую программу для микроконтроллера происходит в два основных этапа:

=== Компиляция (трансляция)
- Компилятор переводит исходный код (файлы `.cpp` и `.h`) в *объектные файлы* — машинно-ориентированный код.
- На этом этапе также могут создаваться библиотеки для повторного использования.

=== Компоновка (линковка)
- Линковщик объединяет объектные файлы, стандартные библиотеки и конфигурационные файлы.
- Результат — *исполняемый файл* в формате ELF, готовый к загрузке в микроконтроллер.
- Линковщик распределяет код и данные по адресному пространству (ПЗУ и ОЗУ) согласно настройкам.

== Запуск программы: что происходит до `main()`

Перед запуском основной программы (`main()`) система выполняет критически важные подготовительные действия:

- **Инициализация стека**: указатель стека (SP) устанавливается на верхнюю границу области стека.
- **Инициализация переменных**:
  **Zero-initialized data**: глобальные переменные без явной инициализации обнуляются.
  **Initialized data**: переменные с начальными значениями копируются из ПЗУ в ОЗУ.
- **Вызов `main()`**: только после инициализации управление передаётся в функцию `main()`.

== Роль файла `startup.cpp`

Файл `startup.cpp` (или `estartup.cpp`) содержит:

- Таблицу векторов прерываний.
- Код начальной инициализации системы.
- Точку входа `__iar_program_start`, которая вызывает `__cmain`, а затем `main()`.

Пример структуры файла:
[source,cpp]
----
extern "C" void __iar_program_start(void);
void __iar_program_start(void) {
    __iar_init_core();
    __iar_init_vfp();
    __cmain();  // вызывает main()
}
----

== Организация памяти и сегменты

Память в микроконтроллере организуется в сегменты:

- **.text**: исполняемый код (размещается в ПЗУ).
- **.data**: инициализированные переменные (ОЗУ).
- **.bss**: нулевые/неинициализированные переменные (ОЗУ).
- **.stack**: стек программы.
- **.heap**: динамическая память.

Настройка памяти выполняется через файл линковщика (`.icf`), где задаются адреса ПЗУ и ОЗУ.

Пример настройки:
[source,text]
----
define symbol __ICFEDIT_region_ROM_start__ = 0x08000000;
define symbol __ICFEDIT_region_ROM_end__   = 0x0807FFFF;
define region ROM_region = mem:[from __ICFEDIT_region_ROM_start__ to __ICFEDIT_region_ROM_end__];
----

== Отладка и загрузка

- Исполняемый файл загружается в микроконтроллер через отладчик (ST-LINK) или симулятор.
- IAR C-SPY позволяет отлаживать код на уровне исходников и ассемблера.
- Анализ стека помогает определить максимальный размер стека для глубоких цепочек вызовов.

== Заключение

Процесс от написания кода до его выполнения на микроконтроллере включает:
- Компиляцию и линковку.
- Настройку памяти и стека.
- Инициализацию системы до вызова `main()`.
- Загрузку и отладку через специализированные инструменты.

Использование современных сред разработки, таких как IAR Embedded Workbench, значительно упрощает и автоматизирует эти процессы, позволяя сосредоточиться на логике приложения.

=== Подключение платы к ПК
image:Figa1.jpg[]